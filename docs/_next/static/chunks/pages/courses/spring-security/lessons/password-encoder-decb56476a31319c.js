(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[761],{9330:function(a,b,c){(window.__NEXT_P=window.__NEXT_P||[]).push(["/courses/spring-security/lessons/password-encoder",function(){return c(4922)}])},4621:function(c,a,b){"use strict";var d=b(5893);a.Z=function(a){var c=a.src,b=a.title;return(0,d.jsxs)("div",{className:"p-3",children:[(0,d.jsx)("div",{className:"mb-3 text-secondary text-center",children:(0,d.jsx)("em",{children:b})}),(0,d.jsx)("img",{className:"img-fluid rounded border shadow",src:c,alt:b})]})}},4922:function(f,b,a){"use strict";a.r(b);var g=a(5893),h=a(9963),i=a(130),j=a(7291),k=a(476),l=a(4621),c=a(9827),d=a(9927),e=a(358);b.default=(0,c.default)(function(b){var a=b.githubPath;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsxs)("section",{children:[(0,g.jsx)(h.nL,{children:"Password Encoder"}),(0,g.jsxs)(i.Z,{children:["In the last chapter, we mentioned that we have not encrypted the password for any users in the database. You might also have noticed from the ",(0,g.jsx)("u",{children:"ListStudents"})," API response that the passwords are all just plain text."]}),(0,g.jsx)(i.Z,{children:"Storing passwords in plain text is a terrible idea that any level of database compromise will expose your application users. It could be logging the passwords by mistake or inadequately securing the database dumps etc., We must encrypt the password using irreversible cryptographic functions that even the system / database administrators could not retrieve them."}),(0,g.jsxs)(i.Z,{children:["In this chapter, we will introduce the most commonly used ",(0,g.jsx)(j.Z,{children:"BCryptPasswordEncoder"})," offered by Spring Security."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"BCryptPasswordEncoder"}),(0,g.jsxs)(i.Z,{children:[(0,g.jsx)(j.Z,{children:"BCryptPasswordEncoder"})," is one of the implementations of the ",(0,g.jsx)(j.Z,{children:"PasswordEncoder"})," interface. It helps us to ",(0,g.jsx)("em",{children:"encode"})," the password as well as ",(0,g.jsx)("em",{children:"match"})," the raw password with the encoded password on authentication."]}),(0,g.jsxs)(i.Z,{children:["Let's create and register ",(0,g.jsx)(j.Z,{children:"BCryptPasswordEncoder"})," bean in the ",(0,g.jsx)(j.Z,{children:"SecurityBean"})," class."]}),(0,g.jsx)(k.Z,{fileName:"SecurityBean.java",href:a+"/src/main/java/com/facadecode/spring/security/config/SecurityBean.java",children:"\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n"})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Encrypt the passwords"}),(0,g.jsxs)(i.Z,{children:["Autowire the ",(0,g.jsx)(j.Z,{children:"PasswordEncoder"})," in ",(0,g.jsx)(j.Z,{children:"AppDataInitialiser"}),", and then use it to encrypt the password for all the users before saving it in the database like below:"]}),(0,g.jsx)(k.Z,{fileName:"AppDataInitialiser.java",href:a+"/src/main/java/com/facadecode/spring/security/config/AppDataInitialiser.java",children:'\nAppUser gruUser = AppUser.builder()\n        .username("Gru")\n        .password(passwordEncoder.encode("password"))\n        .email("gru@email.com")\n        .roles(Collections.singleton(instructorRole))\n        .build();\n'}),(0,g.jsxs)(i.Z,{children:["Restarting the application triggers ",(0,g.jsx)(j.Z,{children:"AppDataInitialiser"})," to clear the database and recreate all the user records with encrypted passwords."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Update UserDetails"}),(0,g.jsxs)(i.Z,{children:["In order to let Spring Security know that we have used ",(0,g.jsx)(j.Z,{children:"BCryptPasswordEncoder"})," to encrypt the passwords, we might think to replace the prefix for each password from ",(0,g.jsx)(j.Z,{children:"{noop}"})," to ",(0,g.jsx)(j.Z,{children:"{bcrypt}"}),". But it is no longer required as Spring Security is already aware of the ",(0,g.jsx)(j.Z,{children:"PasswordEncoder"})," bean available in the ApplicationContext. Let's remove the prefix and map the password directly while creating the ",(0,g.jsx)(j.Z,{children:"UserDetails"})," list in ",(0,g.jsx)(j.Z,{children:"DbUserDetailsService"}),"."]}),(0,g.jsx)(k.Z,{fileName:"DbUserDetailsService.java",href:a+"/src/main/java/com/facadecode/spring/security/service/DbUserDetailsService.java",children:"\npublic List<UserDetails> getAllUserDetails() {\n    return appUserRepository.findAll()\n            .stream()\n            .map(appUser -> User.builder()\n                    .username(appUser.getUsername())\n                    .password(appUser.getPassword())\n                    .authorities(Collections.EMPTY_SET)\n                    .build()\n            )\n            .collect(Collectors.toList());\n}\n"}),(0,g.jsxs)(i.Z,{children:["In addition to encrypting the passwords, ",(0,g.jsx)(j.Z,{children:"BCryptPasswordEncoder"})," bean will be automatically used by Spring Security for password verification also using ",(0,g.jsx)(j.Z,{children:"matches()"})," method."]}),(0,g.jsxs)(i.Z,{children:["Restart the application and send a GET request to the ",(0,g.jsx)("u",{children:"ListStudents"})," API from Postman as Bob user. You can see from the response that all the passwords are encrypted now."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson06-01.png",title:"Passwords are encrypted for all the users"}),(0,g.jsxs)(i.Z,{children:["Though the passwords are encrypted, it is still not a good practice to expose them in any manner. Let's add ",(0,g.jsx)(j.Z,{children:"@JsonIgnore"})," annotation to the ",(0,g.jsx)("em",{children:"password"})," field in ",(0,g.jsx)(j.Z,{children:"AppUser"})," entity to ignore serializing it."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson06-02.png",title:"Passwords are removed from the response"})]})]})},(0,e.s)(d.Z,"password-encoder"))}},function(a){a.O(0,[116,891,637,462,774,888,179],function(){var b;return a(a.s=9330)}),_N_E=a.O()}])