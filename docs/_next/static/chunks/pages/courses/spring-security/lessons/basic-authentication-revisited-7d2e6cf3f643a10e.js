(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[811],{5863:function(a,b,c){(window.__NEXT_P=window.__NEXT_P||[]).push(["/courses/spring-security/lessons/basic-authentication-revisited",function(){return c(4737)}])},4621:function(c,a,b){"use strict";var d=b(5893);a.Z=function(a){var c=a.src,b=a.title;return(0,d.jsxs)("div",{className:"p-3",children:[(0,d.jsx)("div",{className:"mb-3 text-secondary text-center",children:(0,d.jsx)("em",{children:b})}),(0,d.jsx)("img",{className:"img-fluid rounded border shadow",src:c,alt:b})]})}},4737:function(f,b,a){"use strict";a.r(b);var g=a(5893),h=a(9963),i=a(130),j=a(7291),k=a(476),l=a(4621),c=a(9827),d=a(9927),e=a(358);b.default=(0,c.default)(function(a){var b=a.githubPath;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsxs)("section",{children:[(0,g.jsx)(h.nL,{children:"Basic Authentication Revisited"}),(0,g.jsxs)(i.Z,{children:["Let's send a GET request to ",(0,g.jsx)("u",{children:"List Students"})," API with Admin user credentials using Basic Auth. Once we get the success response, change the Type of Authorization from Basic to No Auth and send the request again. Surprisingly we get a success response though we did not send Admin user credentials the second time."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson21-01.png",title:"Successful response for secured Admin APIs with No Auth"}),(0,g.jsxs)(i.Z,{children:["This is because of the user session created in the first request. By default Spring Security creates a ",(0,g.jsx)(j.Z,{children:"HttpSession"})," and attach the JSESSIONID as cookie in the response. This cookie is sent back on subsequent requests to identify the user without the need to send username and password on those requests."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson21-02.png",title:"JSESSIONID cookie sent along with No Auth request to identify the user"})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Stateless Session"}),(0,g.jsxs)(i.Z,{children:["While we said Basic Auth is stateless where each request must contain username and password, but nothing stops you from making it stateful by creating a ",(0,g.jsx)(j.Z,{children:"HttpSession"})," for the requested user. May be we can say Basic Auth is designed to be stateless when we disable the Cookies (Turn ON Disable cookie jar option in Request settings in Postman) in the user agent. Alternatively we can also override the Spring Security's default behaviour by configuring ",(0,g.jsx)("em",{children:"sessionManagement"})," in ",(0,g.jsx)(j.Z,{children:"HttpSecurity"})," to make it stateless like below."]}),(0,g.jsx)(k.Z,{fileName:"ApiSecurityConfig.java",href:b+"/src/main/java/com/facadecode/spring/security/config/ApiSecurityConfig.java",children:"\n@Configuration\npublic class ApiSecurityConfig {\n    @Bean\n    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()\n            .sessionManagement(\n                httpSecuritySessionManagementConfigurer ->\n                        httpSecuritySessionManagementConfigurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            )\n            .authorizeRequests(auth -> auth\n                .antMatchers(GET, PUBLIC_API_LIST).permitAll()\n                .anyRequest().authenticated()\n            )\n            .httpBasic();\n        return http.build();\n    }\n}\n"})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Stateless Basic Auth"}),(0,g.jsx)(i.Z,{children:"The problem with Basic Auth being stateless is the user does not have the option to login or logout. As a result they have to get them identified repeatedly on every request with their username and password. This will not be a nice user experience for the web applications. And having the user credentials in transit for a number of times poses serious security threats."}),(0,g.jsx)(i.Z,{children:"As these credentials are merely Base64 encoded, and not encrypted, Basic Auth is typically used in conjunction with HTTPS to provide confidentiality. Having said that Basic Auth might suit machine to machine interactions provided the credentials are stored and transferred securely over HTTPS, however it is not suitable for most of the scenarios for the drawbacks mentioned above."})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Stateful Basic Auth"}),(0,g.jsx)(i.Z,{children:"Basic Auth over HTTPS with Cookies and Sessions enabled resolves most of the above issues and is still a good choice for some of the use cases. Also Spring Security provides out of the box support to Session management with no extra code as we saw from its default behaviour before making it Stateless in this chapter. But one should be aware of some of the issues inherent to Session."})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Spring Session"}),(0,g.jsx)(i.Z,{children:"Spring Session - a container independent solution - can be used to support such clustered sessions without being tied to a specific instance. This can be most suitable when we have multiple instances of homogeneous (same monolithic) applications sharing the same datastore."}),(0,g.jsx)(i.Z,{children:"However the concept of User Session itself does not go well with Microservice style architecture where we can have multiple instances of heterogeneous applications/services. Each service can have its own datastore and the choice of storage system can also differ."}),(0,g.jsx)(i.Z,{children:"The way to go forward with Session-free authentication and with no need for sending username and password on every request is Token Based Authentication."})]})]})},(0,e.s)(d.Z,"basic-authentication-revisited"))}},function(a){a.O(0,[116,891,637,462,774,888,179],function(){var b;return a(a.s=5863)}),_N_E=a.O()}])