(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[584],{6090:function(a,b,c){(window.__NEXT_P=window.__NEXT_P||[]).push(["/courses/spring-security/lessons/permission-evaluator-strategy",function(){return c(9565)}])},4621:function(c,a,b){"use strict";var d=b(5893);a.Z=function(a){var c=a.src,b=a.title;return(0,d.jsxs)("div",{className:"p-3",children:[(0,d.jsx)("div",{className:"mb-3 text-secondary text-center",children:(0,d.jsx)("em",{children:b})}),(0,d.jsx)("img",{className:"img-fluid rounded border shadow",src:c,alt:b})]})}},9565:function(f,b,a){"use strict";a.r(b);var g=a(5893),h=a(9963),i=a(130),j=a(7291),k=a(476),c=a(9827),d=a(9927),e=a(358);a(4621),b.default=(0,c.default)(function(b){var a=b.githubPath;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsxs)("section",{children:[(0,g.jsx)(h.nL,{children:"PermissionEvaluator Strategy"}),(0,g.jsxs)(i.Z,{children:["As we can register only one ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," implementation, let's create a master implementation to delegate the authorization check to the appropriate ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," based on the type of the ",(0,g.jsx)(j.Z,{children:"targetDomainObject"}),". And we can register this master ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," with ",(0,g.jsx)(j.Z,{children:"DefaultMethodSecurityExpressionHandler"}),"."]}),(0,g.jsxs)(i.Z,{children:["The above idea aligns with the ",(0,g.jsx)("strong",{children:"Strategy Pattern"})," which allows us to define a family of algorithms or strategies and choose one  among them at run time. In our case the strategies are the various ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," implementations for each domain class."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Strategy Interface"}),(0,g.jsxs)(i.Z,{children:["Our first step is to identify all the strategies through a common interface. Let's create a ",(0,g.jsx)("strong",{children:"Strategy"})," interface extending ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," interface. And then we will update each strategies i.e., ",(0,g.jsx)(j.Z,{children:"CoursePermissionEvaluator"})," and ",(0,g.jsx)(j.Z,{children:"AppUserPermissionEvaluator"})," to implement the ",(0,g.jsx)("strong",{children:"Strategy"})," interface."]}),(0,g.jsx)(k.Z,{fileName:"PermissionEvaluatorStrategy.java",href:a+"/src/main/java/com/facadecode/spring/security/security/PermissionEvaluatorStrategy.java",children:"\npublic interface PermissionEvaluatorStrategy<T> extends PermissionEvaluator {\n    <T> Class<T> getTargetType();\n}\n"}),(0,g.jsx)(k.Z,{fileName:"CoursePermissionEvaluator.java",href:a+"/src/main/java/com/facadecode/spring/security/security/CoursePermissionEvaluator.java",children:"\n@Component\npublic class CoursePermissionEvaluator implements PermissionEvaluatorStrategy<Course> {\n    // hasPermission() overloaded methods omitted for brevity\n\n    @Override\n    public Class<Course> getTargetType() {\n        return Course.class;\n    }\n}\n"}),(0,g.jsx)(k.Z,{fileName:"AppUserPermissionEvaluator.java",href:a+"/src/main/java/com/facadecode/spring/security/security/AppUserPermissionEvaluator.java",children:"\n@Component\npublic class AppUserPermissionEvaluator implements PermissionEvaluatorStrategy<AppUser> {\n    // hasPermission() overloaded methods omitted for brevity\n\n    @Override\n    public Class<AppUser> getTargetType() {\n        return AppUser.class;\n    }\n}\n"}),(0,g.jsxs)(i.Z,{children:["We created the ",(0,g.jsx)("strong",{children:"Strategy"})," interface with Generics where the parameterised type in each implementation class must represent the corresponding ",(0,g.jsx)("em",{children:"Entity"})," class. It ensures each domain class to have its own ",(0,g.jsx)(j.Z,{children:"PermissionEvaluatorStrategy"})," implementation. And for our convenience we have added ",(0,g.jsx)(j.Z,{children:"getTargetType()"})," to return the Class Type of the domain class, in order to identify the right strategy based on the type of the ",(0,g.jsx)(j.Z,{children:"targetDomainObject"}),"."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"StrategyContext"}),(0,g.jsxs)(i.Z,{children:[(0,g.jsx)("strong",{children:"Strategy Pattern"})," suggests to let the ",(0,g.jsx)("em",{children:"Client"})," choose one of the strategies and encapsulate it inside a ",(0,g.jsx)("em",{children:"StrategyContext"})," class. The ",(0,g.jsx)("em",{children:"Client"})," will then call the ",(0,g.jsx)("em",{children:"StrategyContext"})," to delegate the execution to the encapsulated Strategy."]}),(0,g.jsxs)(i.Z,{children:["In our case we will use the master ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," to have the responsibilities of both ",(0,g.jsx)("em",{children:"Client"})," and ",(0,g.jsx)("em",{children:"StrategyContext"}),". Let's create ",(0,g.jsx)(j.Z,{children:"PermissionEvaluatorStrategyContext"})," class to encapsulate all the strategies, choose one among them at runtime and delegate the authorization check to the chosen strategy."]}),(0,g.jsx)(k.Z,{fileName:"PermissionEvaluatorStrategyContext.java",href:a+"/src/main/java/com/facadecode/spring/security/security/PermissionEvaluatorStrategyContext.java",children:"\n@Component\npublic class PermissionEvaluatorStrategyContext implements PermissionEvaluator {\n    @Override\n    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {\n        if (targetDomainObject != null) {\n            String targetType = targetDomainObject.getClass().getSimpleName();\n            if (hasAuthority(authentication, permission)) {\n                PermissionEvaluator permissionEvaluatorDelegate = getPermissionEvaluator(targetType);\n                return permissionEvaluatorDelegate.hasPermission(authentication, targetDomainObject, permission);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {\n        if (targetId != null) {\n            if (hasAuthority(authentication, permission)) {\n                PermissionEvaluator permissionEvaluatorDelegate = getPermissionEvaluator(targetType);\n                return permissionEvaluatorDelegate.hasPermission(authentication, targetId, targetType, permission);\n            }\n        }\n        return false;\n    }\n}\n"}),(0,g.jsxs)(i.Z,{children:["Here we are trying to find the appropriate ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," based on the type of the ",(0,g.jsx)(j.Z,{children:"targetDomainObject"})," and delegate the corresponding ",(0,g.jsx)(j.Z,{children:"hasPermission()"})," execution to it. In the first method we are finding it based on the fully qualified class name of the Entity retrieved from the ",(0,g.jsx)(j.Z,{children:"targetDomainObject"}),". Whereas in the second method we are finding it based on the same fully qualified class name of the Entity from the ",(0,g.jsx)(j.Z,{children:"hasPermission()"})," SpEL expression defined in ",(0,g.jsx)(j.Z,{children:"Authority"})," constants."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Find PermissionEvaluator Strategy"}),(0,g.jsxs)(i.Z,{children:["Now the master ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," is capable of delegating the authorization check based on the fully qualified class name of the Entity. We will encapsulate all the strategies by simply autowiring a list variable of type ",(0,g.jsx)(j.Z,{children:"PermissionEvaluatorStrategy"})," like below:"]}),(0,g.jsx)(k.Z,{fileName:"PermissionEvaluatorStrategyContext.java",href:a+"/src/main/java/com/facadecode/spring/security/security/PermissionEvaluatorStrategyContext.java",children:'\n@Component\npublic class PermissionEvaluatorStrategyContext implements PermissionEvaluator {\n    // hasPermission() overloaded methods omitted for brevity\n\n    @Autowired\n    private List<PermissionEvaluatorStrategy> strategies;\n\n    public PermissionEvaluator getPermissionEvaluator(String name) {\n        return strategies.stream()\n            .filter(strategy ->\n                strategy.getTargetType()\n                    .getSimpleName()\n                    .equalsIgnoreCase(name)\n            )\n            .findFirst()\n            .orElseThrow(() -> new RuntimeException(String.format("No permission evaluator found for the class %s", name)));\n    }\n}\n'}),(0,g.jsxs)(i.Z,{children:["We will use ",(0,g.jsx)(j.Z,{children:"getTargetType()"})," method in each strategy to get the fully qualified name of the corresponding Entity. We will then use it to compare it against the argument to find the right strategy. Finally register ",(0,g.jsx)(j.Z,{children:"PermissionEvaluatorStrategyContext"})," class with ",(0,g.jsx)(j.Z,{children:"DefaultMethodSecurityExpressionHandler"})," in ",(0,g.jsx)(j.Z,{children:"SecurityConfig"})," configuration."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Benefits"}),(0,g.jsxs)(i.Z,{children:["By implementing Domain Object Instance Security using ",(0,g.jsx)(j.Z,{children:"hasPermission()"})," SpEL expression and ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," we have achieved more fine-grained access control on each domain object instances based on the attributes of the subject and the object. This is a simple and efficient solution to achieve attribute-based access control using Spring's built-in SpEL capability."]}),(0,g.jsxs)(i.Z,{children:[(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," implementations created for each domain class enable us to understand who are authorized to do what on them. It is easier to manage the permissions with ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," as it owns the permission related to the corresponding domain class defined in the parameterized type."]}),(0,g.jsxs)(i.Z,{children:["In a Microservice architecture each microservice owns only a minor subset of the larger Business domain. And the team who manages each microservice owns the resposibility to secure these domain object instances. Those who do not want to centralize and externalize the authorization policies can define and implement their own domain object permissions using ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})," for each Entity."]})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"What next?"}),(0,g.jsx)(i.Z,{children:"So far we have covered various authorization techniques to secure different layers as mentioned below:"}),(0,g.jsxs)("ol",{children:[(0,g.jsxs)("li",{children:["Web request security using ",(0,g.jsx)(j.Z,{children:"HttpSecurity"})," configuration"]}),(0,g.jsxs)("li",{children:["Service layer security using ",(0,g.jsx)(j.Z,{children:"Method Security Annotations"})]}),(0,g.jsxs)("li",{children:["Domain object instance security using ",(0,g.jsx)(j.Z,{children:"PermissionEvaluator"})]})]}),(0,g.jsxs)(i.Z,{children:["By this we have covered three out of the four security concerns to be addressed for any enterprise applications as suggested by ",(0,g.jsx)("a",{href:"https://docs.spring.io/spring-security/reference/servlet/appendix/faq.html#appendix-faq-web-xml",target:"_blank",children:"Spring Security"}),". One of the security concerns left to be covered is ",(0,g.jsx)(j.Z,{children:"Authentication"}),". Of course we enabled Basic Authentication at the start of the course and using it until now to authenticate the user. But there are a wide range of options available to implement Authentication. We will discuss some of the widely used authentication mechanisms using Spring Security in the upcoming chapters."]}),(0,g.jsxs)(i.Z,{children:["Before that let us replace ",(0,g.jsx)(j.Z,{children:"InMemoryUserDetailsManager"})," with our own ",(0,g.jsx)(j.Z,{children:"UserDetailsService"})," implementation in the next chapter."]})]})]})},(0,e.s)(d.Z,"permission-evaluator-strategy"))}},function(a){a.O(0,[116,891,637,462,774,888,179],function(){var b;return a(a.s=6090)}),_N_E=a.O()}])